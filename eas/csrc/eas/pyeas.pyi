from __future__ import annotations
import eas
import numpy
import pybind11_stubgen.typing_ext
import typing
__all__ = ['AbruptDhCfrSolver', 'AbruptDhState', 'AbruptDhTraverser', 'AbruptPtttCfrSolver', 'AbruptPtttState', 'AbruptPtttTraverser', 'Averager', 'AveragingStrategy', 'CfrConf', 'CfrSolver', 'CornerDhCfrSolver', 'CornerDhState', 'CornerDhTraverser', 'DhCfrSolver', 'DhState', 'DhTraverser', 'EvExpl', 'PtttCfrSolver', 'PtttState', 'PtttTraverser']
class AbruptDhCfrSolver:
    def __init__(self, traverser: AbruptDhTraverser, cfr_conf: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class AbruptDhState:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> AbruptDhState:
        ...
    def compute_openspiel_infostate(self) -> numpy.ndarray[bool]:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, cell: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class AbruptDhTraverser:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def compute_openspiel_infostates(self, player: int) -> numpy.ndarray[bool]:
        ...
    def construct_uniform_strategies(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def ev_and_exploitability(self, strat0: numpy.ndarray[numpy.float64], strat1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, player: int, avg_strategy: AveragingStrategy) -> Averager:
        ...
    def parent_index_and_action(self, player: int, row: int) -> tuple[int, int]:
        ...
    def row_for_infoset(self, player: int, infoset_desc: str) -> int:
        ...
    @property
    def NUM_INFOS_PL0(self) -> int:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
class AbruptPtttCfrSolver:
    def __init__(self, traverser: AbruptPtttTraverser, cfr_conf: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class AbruptPtttState:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> AbruptPtttState:
        ...
    def compute_openspiel_infostate(self) -> numpy.ndarray[bool]:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, cell: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class AbruptPtttTraverser:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def compute_openspiel_infostates(self, player: int) -> numpy.ndarray[bool]:
        ...
    def construct_uniform_strategies(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def ev_and_exploitability(self, strat0: numpy.ndarray[numpy.float64], strat1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, player: int, avg_strategy: AveragingStrategy) -> Averager:
        ...
    def parent_index_and_action(self, player: int, row: int) -> tuple[int, int]:
        ...
    def row_for_infoset(self, player: int, infoset_desc: str) -> int:
        ...
    @property
    def NUM_INFOS_PL0(self) -> int:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
class Averager:
    def clear(self) -> None:
        ...
    def push(self, strategy: numpy.ndarray[numpy.float64], weight: float | None = None) -> None:
        ...
    def running_avg(self) -> numpy.ndarray[numpy.float64]:
        ...
class AveragingStrategy:
    """
    Members:
    
      UNIFORM
    
      LINEAR
    
      QUADRATIC
    
      EXPERIMENTAL
    
      LAST
    
      CUSTOM
    """
    CUSTOM: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.CUSTOM: 5>
    EXPERIMENTAL: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.EXPERIMENTAL: 3>
    LAST: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.LAST: 4>
    LINEAR: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.LINEAR: 1>
    QUADRATIC: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.QUADRATIC: 2>
    UNIFORM: typing.ClassVar[AveragingStrategy]  # value = <AveragingStrategy.UNIFORM: 0>
    __members__: typing.ClassVar[dict[str, AveragingStrategy]]  # value = {'UNIFORM': <AveragingStrategy.UNIFORM: 0>, 'LINEAR': <AveragingStrategy.LINEAR: 1>, 'QUADRATIC': <AveragingStrategy.QUADRATIC: 2>, 'EXPERIMENTAL': <AveragingStrategy.EXPERIMENTAL: 3>, 'LAST': <AveragingStrategy.LAST: 4>, 'CUSTOM': <AveragingStrategy.CUSTOM: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CfrConf:
    DCFR: typing.ClassVar[CfrConf]  # value = CfrConf(avg=quadratic, alternation=true, dcfr=true, rmplus=false, predictive=false)
    PCFRP: typing.ClassVar[CfrConf]  # value = CfrConf(avg=quadratic, alternation=true, dcfr=false, rmplus=true, predictive=true)
    alternation: bool
    avg: AveragingStrategy
    dcfr: bool
    predictive: bool
    rmplus: bool
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, *, avg: AveragingStrategy = eas.AveragingStrategy.QUADRATIC, alternation: bool = True, dcfr: bool = True, rmplus: bool = False, predictive: bool = False) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class CornerDhCfrSolver:
    def __init__(self, traverser: CornerDhTraverser, cfr_conf: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class CornerDhState:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> CornerDhState:
        ...
    def compute_openspiel_infostate(self) -> numpy.ndarray[bool]:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, cell: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class CornerDhTraverser:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def compute_openspiel_infostates(self, player: int) -> numpy.ndarray[bool]:
        ...
    def construct_uniform_strategies(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def ev_and_exploitability(self, strat0: numpy.ndarray[numpy.float64], strat1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, player: int, avg_strategy: AveragingStrategy) -> Averager:
        ...
    def parent_index_and_action(self, player: int, row: int) -> tuple[int, int]:
        ...
    def row_for_infoset(self, player: int, infoset_desc: str) -> int:
        ...
    @property
    def NUM_INFOS_PL0(self) -> int:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
class DhCfrSolver:
    def __init__(self, traverser: DhTraverser, cfr_conf: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class DhState:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> DhState:
        ...
    def compute_openspiel_infostate(self) -> numpy.ndarray[bool]:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, cell: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class DhTraverser:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def compute_openspiel_infostates(self, player: int) -> numpy.ndarray[bool]:
        ...
    def construct_uniform_strategies(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def ev_and_exploitability(self, strat0: numpy.ndarray[numpy.float64], strat1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, player: int, avg_strategy: AveragingStrategy) -> Averager:
        ...
    def parent_index_and_action(self, player: int, row: int) -> tuple[int, int]:
        ...
    def row_for_infoset(self, player: int, infoset_desc: str) -> int:
        ...
    @property
    def NUM_INFOS_PL0(self) -> int:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
class EvExpl:
    def __repr__(self) -> str:
        ...
    @property
    def best_response(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    @property
    def ev0(self) -> float:
        ...
    @property
    def expl(self) -> tuple[float, float]:
        ...
    @property
    def gradient(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
class PtttCfrSolver:
    def __init__(self, traverser: PtttTraverser, cfr_conf: CfrConf) -> None:
        ...
    def avg_bh(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def step(self) -> None:
        ...
class PtttState:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def action_mask(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def clone(self) -> PtttState:
        ...
    def compute_openspiel_infostate(self) -> numpy.ndarray[bool]:
        ...
    def infoset_desc(self) -> str:
        ...
    def is_terminal(self) -> bool:
        ...
    def next(self, cell: int) -> None:
        ...
    def player(self) -> int | None:
        ...
    def winner(self) -> int | None:
        ...
class PtttTraverser:
    OPENSPIEL_INFOSTATE_SIZE: typing.ClassVar[int] = 108
    def __init__(self) -> None:
        ...
    def compute_openspiel_infostates(self, player: int) -> numpy.ndarray[bool]:
        ...
    def construct_uniform_strategies(self) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64]]:
        ...
    def ev_and_exploitability(self, strat0: numpy.ndarray[numpy.float64], strat1: numpy.ndarray[numpy.float64]) -> EvExpl:
        ...
    def infoset_desc(self, player: int, row: int) -> str:
        ...
    def new_averager(self, player: int, avg_strategy: AveragingStrategy) -> Averager:
        ...
    def parent_index_and_action(self, player: int, row: int) -> tuple[int, int]:
        ...
    def row_for_infoset(self, player: int, infoset_desc: str) -> int:
        ...
    @property
    def NUM_INFOS_PL0(self) -> int:
        ...
    @property
    def NUM_INFOS_PL1(self) -> int:
        ...
@typing.overload
def CfrSolver(traverser: DhTraverser, cfr_conf: CfrConf) -> DhCfrSolver:
    ...
@typing.overload
def CfrSolver(traverser: AbruptDhTraverser, cfr_conf: CfrConf) -> AbruptDhCfrSolver:
    ...
@typing.overload
def CfrSolver(traverser: CornerDhTraverser, cfr_conf: CfrConf) -> CornerDhCfrSolver:
    ...
@typing.overload
def CfrSolver(traverser: PtttTraverser, cfr_conf: CfrConf) -> PtttCfrSolver:
    ...
@typing.overload
def CfrSolver(traverser: AbruptPtttTraverser, cfr_conf: CfrConf) -> AbruptPtttCfrSolver:
    ...
